# RAG 检索平台 - 核心设计文档

## 1. 项目概述

这是一个基于 **DDD (领域驱动设计)** 架构的企业级 RAG (Retrieval-Augmented Generation) 检索中台系统。项目的核心特点是**元数据驱动**的动态知识库管理，支持灵活的混合检索和多种融合策略。

### 1.1 核心特性

- **元数据驱动**: 通过字段定义动态配置知识库结构，无需硬编码
- **混合检索**: 支持向量检索、全文检索及混合检索
- **多种融合策略**: Linear Weighting（线性加权）和 RRF（倒数排名融合）
- **策略模式设计**: 可扩展的检索策略和融合策略
- **多租户支持**: 完整的租户隔离机制
- **异步数据摄取**: 基于 Kafka 的异步文档处理流程

### 1.2 技术栈

| 组件 | 技术选型 | 用途 |
|------|---------|------|
| 开发语言 | Java 17 | 核心业务逻辑 |
| 框架 | Spring Boot 3.x | 应用框架 |
| 元数据存储 | PostgreSQL | 知识库配置持久化 |
| 检索引擎 | Elasticsearch 8.x | 文档索引和混合检索 |
| 消息队列 | Kafka | 异步数据摄取 |
| ORM | MyBatis-Plus | 数据持久化 |

---

## 2. 架构设计

### 2.1 DDD 分层架构

项目严格遵循 DDD 四层架构设计：

```
┌─────────────────────────────────────────┐
│        Interfaces Layer (接口层)         │
│   REST API, DTO, Controller             │
└─────────────────────────────────────────┘
                  ↓
┌─────────────────────────────────────────┐
│      Application Layer (应用层)          │
│   SearchService, IngestionService       │
└─────────────────────────────────────────┘
                  ↓
┌─────────────────────────────────────────┐
│        Domain Layer (领域层)             │
│   聚合根, 实体, 值对象, 领域服务          │
│   KnowledgeBase, Document                │
│   SearchStrategy, FusionStrategy         │
└─────────────────────────────────────────┘
                  ↓
┌─────────────────────────────────────────┐
│   Infrastructure Layer (基础设施层)      │
│   ES Client, DB Mapper, Kafka Consumer  │
└─────────────────────────────────────────┘
```

**职责划分**:

- **接口层**: 处理 HTTP 请求，进行 DTO 转换和参数校验
- **应用层**: 协调业务流程，处理跨聚合根的事务
- **领域层**: 核心业务逻辑，包含聚合根、实体、值对象和领域服务
- **基础设施层**: 技术实现细节，包括数据库、Elasticsearch、Kafka 等

---

## 3. 核心领域模型

### 3.1 知识库聚合 (KnowledgeBase Aggregate)

**知识库**是系统的核心聚合根，代表一个完整的检索数据集。

#### 聚合根: `KnowledgeBase`

```java
public class KnowledgeBase {
    private String id;                      // 知识库唯一标识
    private String name;                    // 知识库名称
    private String tenantId;                // 租户 ID
    private KnowledgeBaseStatus status;     // 状态 (CREATING/ACTIVE/INACTIVE)
    private Map<String, FieldDefinition> fieldDefinitions;  // 字段定义集合
    private String indexName;               // 对应的 ES 索引名
}
```

**核心能力**:
- 动态管理字段定义 (`addFieldDefinition`, `updateFieldDefinition`)
- 获取特定类型字段 (`getVectorFields()`, `getTextFields()`)
- 状态转换 (`activate()`, `deactivate()`)
- 生成 ES 索引名 (`generateIndexName()`)

#### 值对象: `FieldDefinition`

字段定义是知识库的核心元数据，定义了数据的结构和索引方式。

```java
public class FieldDefinition {
    private String fieldName;               // 字段名称
    private IndexType indexType;            // 索引类型: VECTOR/TEXT/KEYWORD
    private boolean isFilter;               // 是否可作为过滤条件
    private EmbeddingConfig embeddingConfig;// 向量配置 (仅向量字段)
    private boolean required;               // 是否必填
}
```

**索引类型**:
- `VECTOR`: 向量字段，用于语义检索
- `TEXT`: 全文检索字段，支持分词
- `KEYWORD`: 精确匹配字段，不分词

#### 值对象: `EmbeddingConfig`

```java
public class EmbeddingConfig {
    private String model;                   // 向量模型名称 (如 text-embedding-ada-002)
    private int dimension;                  // 向量维度 (如 1536)
    private String similarity;              // 相似度算法 (cosine/dot_product/l2_norm)
}
```

### 3.2 文档实体 (Document Entity)

```java
public class Document {
    private String docId;                   // 文档唯一标识
    private String knowledgeBaseId;         // 所属知识库
    private Map<String, Object> fields;     // 动态字段数据
    private LocalDateTime createdAt;
}
```

### 3.3 搜索值对象

#### `SearchRequest` - 检索请求

```java
public class SearchRequest {
    private String knowledgeBaseId;              // 知识库 ID
    private String queryText;                    // 查询文本
    private List<RetrievalMethod> retrievalMethods;  // 检索方法列表
    private FusionStrategyType fusionStrategy;   // 融合策略
    private Integer topK;                        // 返回结果数量
    private Map<String, Object> filters;         // 过滤条件
}
```

#### `RetrievalMethod` - 检索方法

```java
public class RetrievalMethod {
    private RetrievalMethodType type;       // VECTOR/TEXT/HYBRID
    private List<String> targetFields;      // 目标字段
    private Double weight;                  // 权重 (用于线性融合)
    private VectorConfig vectorConfig;      // 向量检索配置
    private TextConfig textConfig;          // 文本检索配置
}
```

---

## 4. 核心设计模式

### 4.1 策略模式 - 检索策略

系统使用策略模式实现不同的检索方式，便于扩展新的检索算法。

```
                ┌─────────────────┐
                │ SearchStrategy  │ (接口)
                └─────────────────┘
                         △
            ┌────────────┼────────────┐
            │            │            │
   ┌────────┴─────┐  ┌──┴──────────┐ ┌┴───────────┐
   │VectorSearch  │  │ TextSearch  │ │HybridSearch│
   │   Strategy   │  │  Strategy   │ │  Strategy  │
   └──────────────┘  └─────────────┘ └────────────┘
```

**实现类**:
- `VectorSearchStrategy`: 基于 kNN 的向量检索
- `TextSearchStrategy`: 基于 BM25 的全文检索
- `HybridSearchStrategy`: (可扩展) 在单次查询中结合向量和文本

**工厂类**: `SearchStrategyFactory` 负责根据检索类型返回对应策略实例。

### 4.2 策略模式 - 融合策略

多个检索结果的融合同样采用策略模式设计。

```
                ┌─────────────────┐
                │ FusionStrategy  │ (接口)
                └─────────────────┘
                         △
            ┌────────────┼────────────┐
            │                         │
   ┌────────┴─────────┐     ┌────────┴──────────┐
   │LinearWeightFusion│     │   RRFFusion       │
   │    Strategy      │     │   Strategy        │
   └──────────────────┘     └───────────────────┘
```

**融合策略详解**:

#### Linear Weighting (线性加权)
```
score_final = w1 × score_vector + w2 × score_text
```
- 对每个检索方法的分数进行加权求和
- 权重 `w1`, `w2` 在 `RetrievalMethod` 中配置
- 适用场景: 明确知道不同检索方法的重要性

#### RRF (Reciprocal Rank Fusion)
```
score_final = Σ (1 / (k + rank_i))
```
- `k`: 常数参数，通常为 60
- `rank_i`: 文档在第 i 个检索结果中的排名
- **优点**: 不依赖原始分数，只看排名，对不同分数尺度的结果更鲁棒
- 适用场景: 不同检索方法的分数不在同一量级

### 4.3 工厂模式

- `SearchStrategyFactory`: 创建检索策略实例
- `FusionStrategyFactory`: 创建融合策略实例

工厂模式将对象创建逻辑集中管理，避免在业务代码中直接 `new` 策略对象。

### 4.4 仓储模式 (Repository Pattern)

```java
public interface KnowledgeBaseRepository {
    Optional<KnowledgeBase> findById(String id);
    List<KnowledgeBase> findByTenantId(String tenantId);
    KnowledgeBase save(KnowledgeBase knowledgeBase);
    void delete(String id);
}
```

- 领域层定义接口 (`KnowledgeBaseRepository`)
- 基础设施层实现接口 (`KnowledgeBaseRepositoryImpl`)
- 隔离领域模型与数据访问细节

---

## 5. 核心业务流程

### 5.1 知识库创建流程

```
1. 用户提交知识库定义 (名称、字段定义)
         ↓
2. 应用层: SearchService.createKnowledgeBase()
         ↓
3. 领域层: 创建 KnowledgeBase 聚合根
         ↓
4. 持久化: 保存到 PostgreSQL (状态: CREATING)
         ↓
5. 基础设施层: 根据字段定义动态创建 ES 索引
         ↓
6. 更新状态为 ACTIVE
```

**关键代码**: 
- [SearchService.java](src/main/java/com/enterprise/rag/application/service/SearchService.java#L79-L90)
- [ElasticsearchIndexManager.java](src/main/java/com/enterprise/rag/infrastructure/elasticsearch/ElasticsearchIndexManager.java#L39-L61)

### 5.2 文档摄取流程

```
1. 外部系统发送消息到 Kafka Topic
         ↓
2. IngestionConsumer 消费消息
         ↓
3. IngestionService 处理摄取逻辑
         ↓
4. 向量字段调用 EmbeddingClient 生成向量
         ↓
5. ElasticsearchDocumentClient 写入文档到 ES
         ↓
6. 返回摄取结果
```

**异步优势**:
- 解耦数据源和检索系统
- 支持大批量数据摄取
- 失败重试机制

### 5.3 混合检索流程

这是系统最核心的业务流程。

```
1. 接收 SearchRequest
         ↓
2. 加载 KnowledgeBase 元数据
         ↓
3. 生成查询向量 (如果包含向量检索)
         ↓
4. 并行执行多个检索方法:
   ├─ VectorSearchStrategy → ES kNN 查询
   ├─ TextSearchStrategy   → ES match 查询
   └─ ...
         ↓
5. 收集各检索方法的结果
         ↓
6. FusionStrategy 融合多路结果
         ↓
7. 应用过滤条件和分数阈值
         ↓
8. 返回 SearchResult
```

**关键代码**: 
- [FusionProcessor.java](src/main/java/com/enterprise/rag/domain/service/fusion/FusionProcessor.java#L36-L89)

---

## 6. Elasticsearch 索引设计

### 6.1 动态 Mapping 生成

系统的核心创新在于**元数据驱动的动态索引创建**。

**设计思路**:
1. 用户定义字段时，系统自动生成对应的 ES mapping
2. 向量字段会自动创建两个 ES 字段:
   - `content` (原文，类型: text)
   - `content_vector` (向量，类型: dense_vector)

**Mapping 构建流程**:

```java
// ElasticsearchIndexManager.buildProperties()
Map<String, Property> properties = new HashMap<>();

// 1. 添加系统字段
properties.put("_doc_id", keyword);
properties.put("_knowledge_base_id", keyword);
properties.put("_created_at", date);

// 2. 根据 FieldDefinition 动态构建字段
for (FieldDefinition fd : knowledgeBase.getFieldDefinitionList()) {
    if (fd.isVectorField()) {
        properties.put(fd.getFieldName(), text);  // 原文
        properties.put(fd.getVectorFieldName(), denseVector);  // 向量
    } else if (fd.isTextField()) {
        properties.put(fd.getFieldName(), text);
    } else {
        properties.put(fd.getFieldName(), keyword);
    }
}
```

### 6.2 Index Template

系统使用 ES Index Template 定义统一的索引模板，详见 [Elasticsearch Mapping 设计文档](./ES-Mapping设计文档.md)。

---

## 7. 扩展性设计

### 7.1 新增检索策略

1. 实现 `SearchStrategy` 接口
2. 在 `SearchStrategyFactory` 中注册
3. 定义新的 `RetrievalMethodType` 枚举值

### 7.2 新增融合策略

1. 实现 `FusionStrategy` 接口
2. 在 `FusionStrategyFactory` 中注册
3. 定义新的 `FusionStrategyType` 枚举值

### 7.3 新增索引类型

1. 在 `IndexType` 枚举中添加新类型
2. 在 `ElasticsearchIndexManager` 中添加 mapping 构建逻辑
3. 更新相关检索策略

---

## 8. 性能优化

### 8.1 向量检索优化

- 使用 **HNSW** (Hierarchical Navigable Small World) 索引算法
- 配置参数:
  - `m = 16`: 每个节点的最大连接数
  - `ef_construction = 100`: 构建时的搜索范围
- `num_candidates`: 召回候选数，通常设为 `topK × 10`

### 8.2 混合检索优化

- **并行执行**: 多个检索方法并行查询 ES
- **Early Stop**: 如果某个检索方法失败，不影响其他方法
- **结果缓存**: (可扩展) 对高频查询结果进行缓存

### 8.3 数据库优化

- 知识库元数据使用 PostgreSQL 索引
- 字段定义序列化为 JSON 存储
- 乐观锁 (`version` 字段) 防止并发冲突

---

## 9. 安全性考虑

### 9.1 多租户隔离

- 每个知识库绑定 `tenantId`
- 所有查询和操作都进行租户级别的权限校验
- ES 索引名包含租户 ID，实现物理隔离

### 9.2 输入校验

- 所有 DTO 使用 Jakarta Validation 注解
- 领域对象在状态变更时进行业务规则校验
- 防止 SQL 注入和 XSS 攻击

---

## 10. 监控与可观测性

### 10.1 日志

- 使用 SLF4J + Logback
- 关键业务操作记录 INFO 级别日志
- 异常和错误记录 ERROR 级别日志

### 10.2 指标 (可扩展)

建议集成 Micrometer + Prometheus，监控:
- 检索响应时间
- 各检索策略的执行次数和耗时
- Kafka 消费延迟
- ES 查询性能

---

## 11. 总结

本系统的核心设计亮点:

1. **元数据驱动**: 通过领域模型动态定义数据结构，灵活适配不同业务场景
2. **DDD 架构**: 清晰的分层设计，领域模型与技术实现解耦
3. **策略模式**: 检索和融合逻辑高度可扩展
4. **混合检索**: 结合语义和关键词检索的优势，提供更精准的结果
5. **企业级特性**: 多租户、异步摄取、事务管理、错误处理

通过这些设计，系统能够快速适应业务需求变化，同时保持代码的可维护性和可扩展性。
